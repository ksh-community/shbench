#!/bin/ksh
# ---------------------------------------------------------------------
# Copyright (c) 2020, Joerg van den Hoff <veedeehjay@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for
# any purpose with or without fee is hereby granted, provided that the
# above copyright notice and this permission notice appear in all
# copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
# WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
# AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
# DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
# PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
# TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
# ---------------------------------------------------------------------
function allgood {
   [[ $KSH_VERSION == Version\ A* ]] || {
      print -u2 "sorry, this script requires ksh93 to run."
      return 1
   }

   # ensure that the targeted shells are present
   typeset sh
   for sh in $shells; do
      $sh -c : || { print -u2 "please install this shell and retry (or exclude it from benchmarking)"; return 1; }
   done

   # check whether all benchmark files are readable
   typeset name
   for name in $benchmarks; do
      [[ -r $name ]] || {
         print -u2 "benchmark '$name' non-existent or not readable. please retry with other benchmarks."
         return 1
      }
   done

   # also do a few tests for not necessarily available tools used here
   # and/or in the benchmark files.
   jot 1 >/dev/null            || { print -u2 please install it and retry; return 1; }
   print 1 | rs 1 > /dev/null  || { print -u2 please install it and retry; return 1; }
}

function printBanner { ## name
   typeset name=$1
   print -u$fd -- "*** $name ***"
}

function timeShell { ## $sh $script
   typeset -i i
   typeset sh=$1 script=$2 shop msg
   [[ $sh == k* ]] && shop=-e || shop=''
   for ((i = 1; i <= loop; i++)); do
      msg+=$({ time $sh $shop "$script"; } 2>&1)
      (($? == 0)) || { print "$msg"; return 1; }
   done
   print $msg
}

function runThis {  ## script
   compound res
   typeset -A cpu
   typeset script="$@"

   for sh in $shells; do
      typeset msg times
      res.shell=$sh
      print -u$fd -n "# $sh"
      msg=$($sh -n "$script" 2>&1) || {  # this isn't a foolproof check!
         print -u$fd ": $msg[1G!"
         res.pass=**skip**
         res.time="real NA user NA sys NA"
         print $res " "
         continue
      }
      times=$(timeShell $sh $script)
      if (($? != 0)); then
         print -u$fd "[1G! $sh: ${times%%$'\n'*}"   ## hopefully the error message but `time' output stripped
         res.pass=**fail**
         set -A cpu "real NA user NA sys NA"
      else
         print -u$fd ""
         res.pass=ok
         set -A cpu $times
      fi
      res.time=${cpu[*]}
      print $res " "
   done
}

function runAll { ## $benchmarks
   typeset benchmarks=$*
   typeset -a times
   typeset -A bm
   typeset name dir benchmark pass
   typeset add repline report
   print -u2 "\nbenchmarking ${shells// /, } ..."
   for benchmark in $benchmarks; do
      name=${benchmark##*/}
      printBanner "$name"
      # explanation: the next line puts the set of compound variables
      # (each containing the results of this benchmark for one of the
      # considered shells) as an indexed array into one element of the
      # associative array `bm'. so `bm' is an (associative) array
      # of (indexed) arrays of compound variables.
      eval "bm[$name]=($(runThis $benchmark))"
   done
   typeset IFS=$'\n'
   integer pos=1
   for name in ${!bm[*]}; do
      unset IFS
      typeset fs=$'\034'
      report+="${name// /$fs} "   # see `mktable' for this replacement
      repline=''
      for i in "${!bm[$name][@]}"; do
         set -A times ${bm[$name][i].time}
         pass=${bm[$name][i].pass}
         if [[ $pass == "ok" ]]; then
            if ((loop > 1)); then
               # determine mean run time and [min, max] range
               float mintime maxtime timeval sdev avgtime=0 sum2=0
               typeset smin smax savg ssdv
               integer idx period=6  # period=6 since "real time user time sys time" ...
               ((mintime = times[1]))
               ((maxtime = times[1]))
               for ((i = 1; i <= loop; i++)); do
                  ((idx = (i - 1) * period + pos))
                  ((timeval = times[idx]))
                  ((avgtime += timeval))
                  ((sum2 += timeval*timeval))
                  ((mintime = timeval < mintime ? timeval:mintime))
                  ((maxtime = timeval > maxtime ? timeval:maxtime))
               done
               ((avgtime /= loop))
               (( sdev = sqrt((sum2 - loop * avgtime * avgtime)/(loop - 1)) ))
               smin=$(print -f %#.2f $mintime)
               smax=$(print -f %#.2f $maxtime)
               savg=$(print -f %#.3f $avgtime)
               ssdv=$(print -f %#.3f $sdev)
               add=$savg
               if ((useRatios == 0)); then
                  ((sdShow)) && add+="${fs}+/-${fs}$ssdv" || add+="${fs}[$smin-$smax]"
               fi
            else
               add=${times[pos]}
            fi
         else
            add=$pass
         fi
         repline+="$add "
      done
      # NOTE TO SELF: trimming the trailing blanks in each line is
      # relevant due to discrepant behaviour of linux `rs' compared to
      # BSD `rs': the latter ignores trailing space (good), the former
      # creates an additional spurious empty record (output line) which
      # messes up `mktable' output.
      repline=${repline% }

      if ((useRatios == 1)); then
         typeset -a ratios
         set -A ratios $repline
         typeset refrat=${ratios[0]}
         typeset val
         for i in ${!ratios[@]}; do
            val=${ratios[i]}
            if [[ $val == *[[:alpha:]]* ]]; then
               continue
            elif [[ $refrat == *[[:alpha:]]* ]]; then
               ratios[i]=NA
            else
               ratios[i]=$(printf '%.3f' $((val/$refrat)))
            fi
         done
         repline=${ratios[@]}
      fi
      report+=$repline
      report+=$'\n'
   done
   print "$report"
}

function mkruler { ## table
   nameref table=$1
   typeset ruler lines
   typeset -i mxlen=0 slen=0
   typeset IFS=$'\n'
   set -A lines $table
   for i in ${lines[*]}; do
      slen=${#i}
      ((mxlen = slen > mxlen ? slen : mxlen))
   done
   for ((i = 0; i < mxlen; i++)); do ruler+="-"; done
   unset IFS
   print $ruler
}

function mktable {  ## report
   # NOTE TO SELF: the ASCII `fs' character (\034) is used in `report'
   # as a placeholder for blanks and replaced accordingly after
   # tabular formatting with `rs'.
   typeset report="$*"
   typeset header
   set -A header name $shells
   typeset -i ncols=${#header[@]}
   typeset table=$(print "name $shells $report" | rs -z 0 $ncols | tr '\034' '\040')
   typeset ruler=$(mkruler table) lf=$'\n'
   table=${table/+([!$lf]$lf)/\1$ruler$lf}
   print "$lf$ruler"
   print "$table"
   print $ruler
}

function setPenalty { ## shell name
   typeset shell=$1
   typeset -A penalties
   penalties=(
      [ksh]=1
      [zsh]=8
      [mksh]=16
      [bash]=16
   )
   # working hypothesis: shells sharing the leading `*sh' glob in
   # their name have comparable performance. so we adjust penalty
   # depending on this identifier
   refshell=${shell/@(*sh)*/\1}
   penalty=${penalties[$refshell]}
   [[ -n $penalty ]] || penalty=${penalties[ksh]}
   export refshell penalty
}

function setup { ## $0
   # some defaults
   fallback="bash ksh"
   bdir=./bench
   # NOTE TO SELF: it seems the `time' builtin reports at most with 10
   # ms accuracy (2 decimal digits). increasing the number of digits
   # in TIMEFORMAT does not help: the third digit is always set to
   # zero. also, it seems 3 digits are the maximum number of printed
   # digits and larger settings are not honoured at all. might need
   # clarification.
   TIMEFORMAT=$'\nreal\t%2R\nuser\t%2U\nsys\t%2S'

   opstring+="[+NAME?${1##*/}]"
   opstring+=$'[+DESCRIPTION?Benchmarking shells.]'
   opstring+=$'[+?Called without options and arguments, all benchmarks
      in the default location "'$bdir'" are run for the default shells
      ('${fallback// /, }').
   ]'
   opstring+=$'[+?Benchmarks can be selected via \a-b\a and have to be
      valid relative or absolute pathnames (assumed to not contain any
      white space). Remember to double quote the argument if multiple
      files are specified (when wildcards are used, it suffices to quote
      these). \a-d path\a is equivalent to \a-b "path/*.ksh"\a and is
      provided for convenience.

   ]'
   opstring+=$'[+?Each benchmark file is executed in a subshell process
      and assumed to contain code that is valid for the considered
      shell(s). Syntax or runtime errors are hopefully handled
      gracefully. Otherwise, benchmarks are required to run completely
      silent and to not generate output on either stderr or stdout.

   ]'
   opstring+=$'[+?Absolute run times are reported in seconds using two
      decimal digits (3 digits if benchmarks are run more than once
      using \a-l\a). Use \a-r\a to report relative run times when
      comparing different shells.

   ]'
   opstring+=$'[+?Results table: benchmarks which do not pass a syntax
      check for the considered shell are skipped and flagged as
      **skip**. Benchmarks failing to complete successfully are flagged
      as **fail**. If \a-r\a is used and the reference shell skips (or
      fails for) a benchmark so that a ratio cannot be computed for
      another (not failing) shell, the respective entry is set to NA.

   ]'
   opstring+=$'[+?The \a-l\a option allows to set a repeat count for
      benchmark execution. This helps to increase timing reliability
      and allows to assess run time variability. If the repeat count is
      > 1, run times are reported as "avg [min-max]]" or, with \a-s\a,
      as "avg +/- sd". If \a-r\a is also specified, run time ratios
      based on the average run times are reported (but ratio variability
      is not provided so far).

   ]'
   opstring+=$'[+TECHNICAL DETAILS?Actual run time of a given benchmark
      and a given shell is controlled by which shell is specified first
      as argument to the call: provisions are in place in the different
      benchmark files to use that shell as the "reference shell" for
      which the run times should be acceptable (order of
      1s/benchmark/run). For example, when calling the script with args
      "ksh mksh" run times are adjusted for ksh (which might lead to
      excessively long run times for mksh) while when calling it with
      args "mksh ksh" the run times are adjusted for mksh (which might
      lead to very short run times of ksh, thus making relative
      performance measurements unreliable).
   ]'
   opstring+=$'[+?The relevant information is stored in 2 exported
      variables "refshell" and "penalty" to which the subshells
      executing the benchmark do have access. The latter is the
      estimated average run time increase of the selected reference
      shell relative to ksh ("the penalty" incured when using anything
      else ;)) and hardcoded in the script. The former ("refshell") can
      be used to adjust individual benchmarks independently if the
      assumed "penalty" is unsuitable for the given reference shell.
      Benchmarks are of course not obliged to honour this information at
      all in which case the run time of the respective benchmark just
      remains independent of the order in which the shells appear in the
      call. Look at the existing benchmarks to get the idea when
      writing further benchmark files.

   ]'
   opstring+=$'[+?Regarding reliability of the timing information,
      the usual caveats apply. Ensure that the used machine is not too
      busy otherwise. Run benchmarks several times using \a-l\a to
      assess how reproducible the measurements are. Short run times are
      inherently less reliable than longer ones (i.e. exhibit larger
      fractional uncertainty). This situation can be only partly
      improved by using \a-l\a with an increased loop count since run
      times are available with only 10 ms accuracy. Furthermore, for
      very short run times the startup time of the subshell (which is of
      the order of 10 ms) becomes non-negligible. Take home message:
      don\'t take average run times below about 0.1-0.2 seconds too
      serious.

   ]'
   opstring+="[b:bm?Select benchmarks to run.]:[benchmarks]"
   opstring+="[d:dir?Location of the benchmark files.]:[bdir:=$bdir]"
   opstring+="[l:loop?Run each benchmark so many times.]#[loop:=$loop]"
   opstring+="[q:quite?Suppress progess report and associated error messages.]"
   opstring+="[r:ratio?Report timing as ratios relative to first specified shell.]"
   opstring+="[s:sd?Report variability as standard deviation rather than min-max range.]"

   opstring+=$'\n\n [shell(s) ...]'
}
# ---------------------------------------------------------------------------
# note: we boldly assume adherence to a no-blanks-in-file-names
# policy at a few points...

typeset fallback bdir opstring opt benchmarks report quite fd=2
integer loop=1 useRatios=0 sdShow=0
typeset -a shells

setup $0

while getopts "$opstring" opt; do
   case $opt in
      b) benchmarks=$OPTARG;;
      d) bdir=$OPTARG;;
      l) ((loop = OPTARG > 1? OPTARG:1));;
      q) fd=3
         eval "redirect $fd> /dev/null"
      ;;
      r) useRatios=1;;
      s) sdShow=1;;
   esac
done
shift $((OPTIND - 1))

(($# == 0)) && set $fallback
shells=${*:-$fallback}
benchmarks=${benchmarks:-$bdir/*.ksh}
setPenalty $1

allgood || exit 1
report=$(runAll $benchmarks)
mktable "$report"
